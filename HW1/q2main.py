# -*- coding: utf-8 -*-
"""kNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GX6RVahf5BJTbOwQuDp693A1TEpRufhD
"""

import pandas as pd
import numpy as np
from time import perf_counter
from google.colab import drive
drive.mount('/content/drive')

def __init__(self, k, features, labels):
    self.k = k
    self.features = features
    self.labels = labels
    self.features_array = self.features.to_numpy()
    self.labels_array = self.labels.to_numpy()
    self.labels_array = self.labels_array.reshape(1, -1)[0]
    self.deleted = []

def calculate_distance(p1, p2):
    dist = 0
    for i in range(len(p1)):
        dist += pow(p1[i] - p2[i], 2)
    dist = pow(dist, 1/2)
    return dist

def calculate_neighbors(data, point, k):
    dist_array = np.full((k, 2), float('inf'))
    for j in range(len(data)):
        dist = calculate_distance(point, data[j])
        if dist == 0:
            continue
        q = k
        while dist < dist_array[q-1, 0] and q > 0:
            q -= 1
        while q < k:
            temp1 = dist_array[q, 0]
            temp2 = dist_array[q, 1]
            dist_array[q, 0] = dist
            dist_array[q, 1] = j
            dist = temp1
            j = temp2
            q += 1
    return dist_array
# feature_temp = features.to_numpy()
# calculate_neighbors(feature_temp, feature_temp[0], 9)

def calculate_params(self):
    t_start = perf_counter()
    self.params = np.zeros((self.labels_array.shape[0], self.k, 2))
    for i in range(len(self.features_array)):
        self.params[i] = calculate_neighbors(self.features_array, self.features_array[i], self.k)
    t_stop = perf_counter()
    return t_stop - t_start

def measure_training_performance(self):
    val_list = []
    for i in self.params[:,:,-1]:
        val = 0
        for ii in i:
            val += self.labels_array[int(ii)]
        val_list.append(val)
    return sum(((np.array(val_list) > 4.5).astype(int) == self.labels_array).astype(int))/len(self.labels_array)

def eliminate_backward_by_one(self, p_val):
    p_val /= 100
    self.calculate_params()
    perf = self.measure_training_performance()
    max_increase = ('',-1,)
    for i in self.features.columns:
        temp_features = self.features.drop(i, axis = 1, inplace = False)
        temp_model = kNN(self.k, temp_features, labels)
        temp_model.calculate_params()
        increase = temp_model.measure_training_performance() - perf
        if increase >= p_val and increase > max_increase[1]:
            max_increase = i, increase, temp_model
    if max_increase[1] >= p_val:
        print("{} deleted, increase: {:.2f}%".format(max_increase[0], max_increase[1]*100))
        temp_list = self.deleted
        self.__class__ = max_increase[2].__class__
        self.__dict__ = max_increase[2].__dict__
        self.deleted = temp_list
    return max_increase[1], max_increase[0]

def fit(self, p_val):
    self.deleted = []
    t_start = perf_counter()
    max_inc, deleted_item = self.eliminate_backward_by_one(p_val)
    t_stop = perf_counter()
    print(t_stop-t_start)
    while max_inc >= p_val:
        self.deleted.append(deleted_item)
        t_start = perf_counter()
        max_inc, deleted_item = self.eliminate_backward_by_one(p_val)
        t_stop = perf_counter()
        print(t_stop-t_start)

def predict(self, test_data):
    test_data = test_data.drop((self.deleted), inplace = False)
    params = calculate_neighbors(self.features_array, test_data, self.k)
    val = 0
    for i in params:
        val += self.labels_array[int(i[1])]
    return int(val > 4.5)

class kNN(object):
    __init__ = __init__
    measure_training_performance = measure_training_performance
    calculate_distance = calculate_distance
    calculate_neighbors = calculate_neighbors
    calculate_params = calculate_params
    eliminate_backward_by_one = eliminate_backward_by_one
    fit = fit
    predict = predict

def normalize(frame):
    min_val = frame.min()
    max_val = frame.max()
    divisor = (max_val - min_val)
    frame = (frame - min_val) / divisor
    return frame

features = pd.read_csv("/content/drive/MyDrive/hw1_datasets/q2/diabetes_train_features.csv", index_col = 0)
labels = pd.read_csv("/content/drive/MyDrive/hw1_datasets/q2/diabetes_train_labels.csv", index_col = 0) 
features = normalize(features)

t_start = perf_counter()
model = kNN(9, features, labels)
model.fit(p_val = 0)
t_stop = perf_counter()
print("performance: {:.2f}%".format(model.measure_training_performance()*100))
print(1000*(t_stop-t_start)//1, "ms")

test_features = pd.read_csv("/content/drive/MyDrive/hw1_datasets/q2/diabetes_test_features.csv", index_col = 0)
test_labels = pd.read_csv("/content/drive/MyDrive/hw1_datasets/q2/diabetes_test_labels.csv", index_col = 0)
test_features = normalize(test_features)

array = []
start = perf_counter()
for i in range(len(test_features)):
    array.append(model.predict(test_features.iloc[i]))
stop = perf_counter()
stop - start

test_arr = test_labels.to_numpy().reshape(1, -1)[0]
array = np.array(array)
100 * sum((test_arr == array).astype(int))/len(test_arr)

